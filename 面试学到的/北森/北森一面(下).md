## 北森一面(中)

## js

> **const为什么定义一个常量就不会修改，但是定义一个对象就可以修改？**
>
> > const保证的不是变量的值不得改动，而是变量指向的那个内存地址不得改动，对于简单类型的数据，值就保存在变量指向的内存地址，因此等于常量，而对于复杂类型而言，变量指向的内存地址保存的只是一个指针，保证这个指针固定，而不能控制指向的数据结构可不可变
> >
> > 将对象冻结应该是用 Object.freeze方法 ，这个可以确定添加新属性不起作用，严格模式会报错
> >
> > MDN const定义
> >
> > > **const**声明创建一个值的只读引用。但这并不意味着它所持有的值是不可变的，只是变量标识符不能重新分配。例如，在引用内容是对象的情况下，这意味着可以改变对象的内容（例如，其参数）。
> >
> > 扩展
> >
> > > 基本类型 存放在栈内存中的简单数据段，数据大小确定，内存空间大小可以分配
> > >
> > > 引用类型 存放在堆内存中的对象，变量实际保存的是一个指针，这个指针指向另一个位置。每个空间大小不一样，要根据情况开进行特定的分配。
> > >
> > > 浅拷贝   在定义一个对象或数组时，变量存放的往往只是一个地址。当我们使用对象拷贝时，如果**属性是对象或数组时**，这时候我们传递的也只是一个地址。因此子对象在访问该属性时，会根据地址回溯到父对象指向的堆内存中，即**父子对象发生了关联**，两者的属性值会指向同一内存空间
> > >
> > > 深拷贝   **不希望父子对象之间产生关联**，那么这时候可以用到**深拷贝** 

## Vuex

> **mutations里边可以执行异步代码吗？**
>
> > 可以，只是不符合标准，标准是在Action中执行异步代码
> >
> > mutations里边不执行异步代码是为了便于测试工具可以监视到数据的变化，这个问题没有思考
> >
> > > 小结
> > >
> > > > vuex的用法还不是很熟练，以后还得加强一下
> > >
> > > 

## webpack

> **loader是用来干什么的？**
>
> > 默认webpack只会处理js代码，所以当我们想要去打包其他内容时，让webpack处理其他类型的内容，就要使用相应的loader，所以laoder是把那些不是js的代码转成js代码
> >
> > 小结
> >
> > > 这个问题为啥做项目的时候不思考一下呢？有点死脑筋，直接引入css的话页面能执行啊，为什么还需要css-loader 和  style-loader呢？还有 ，webpack本来就是基于node的呀，node中根本没有css和html，webpack打包也不会打包成html和css代码呀，按这种逻辑推理也应该得出这些加载器是编译成js代码的呀，为啥就没联想到呢？
>
> **如何生成bundle.js**
>
> > 当有需求要查看bundle.js中的内容时，用什么来生成呢？
> >
> > 
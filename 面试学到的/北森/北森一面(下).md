## 北森一面(下)

## js

> **const为什么定义一个常量就不会修改，但是定义一个对象就可以修改？**
>
> > const保证的不是变量的值不得改动，而是变量指向的那个内存地址不得改动，对于简单类型的数据，值就保存在变量指向的内存地址，因此等于常量，而对于复杂类型而言，变量指向的内存地址保存的只是一个指针，保证这个指针固定，而不能控制指向的数据结构可不可变
> >
> > 将对象冻结应该是用 Object.freeze方法 ，这个可以确定添加新属性不起作用，严格模式会报错
> >
> > MDN const定义
> >
> > > **const**声明创建一个值的只读引用。但这并不意味着它所持有的值是不可变的，只是变量标识符不能重新分配。例如，在引用内容是对象的情况下，这意味着可以改变对象的内容（例如，其参数）。
> >
> > 扩展
> >
> > > 基本类型       存放在栈内存中的简单数据段，数据大小确定，内存空间大小可以分配
> > >
> > > 引用类型       存放在堆内存中的对象，变量实际保存的是一个指针，这个指针指向另一个位置。每个空间大小不一样，要根据情况开进行特定的分配。
> > >
> > > 浅拷贝          在定义一个对象或数组时，变量存放的往往只是一个地址。当我们使用对象拷贝时，如果**属性是对象或数组时**，这时候我们传递的也只是一个地址。因此子对象在访问该属性时，会根据地址回溯到父对象指向的堆内存中，即**父子对象发生了关联**，两者的属性值会指向同一内存空间
> > >
> > > 深拷贝         **不希望父子对象之间产生关联**，那么这时候可以用到**深拷贝** 
>
> **bind如何让this一直指向第一()里边的第一个参数？**
>
> > ```js
> > fn.bind().bind(a)() // => ?
> > //一直指向第一个bind的指向,也就是window
> > 
> > //大体为这样
> > // fn.bind().bind(a) 等于
> > let fn2 = function fn1() {
> >   return function() {
> >     return fn.apply()
> >   }.apply(a)
> > }
> > fn2()
> > ```
> >
> > 小结
> >
> > > 这个也是没整明白，提示我用面向对象的方式，不过我只会用闭包这样来做，而且自己也不会封装，唉，还是菜呀

## Vuex

> **mutations里边可以执行异步代码吗？**
>
> > 可以，只是不符合标准，标准是在Action中执行异步代码
> >
> > mutations里边不执行异步代码是为了便于测试工具可以监视到数据的变化，这个问题没有思考
> >
> > > 小结
> > >
> > > > vuex的用法还不是很熟练，以后还得加强一下
> > >
> > > 

## webpack

> **loader是用来干什么的？**
>
> > 默认webpack只会处理js代码，所以当我们想要去打包其他内容时，让webpack处理其他类型的内容，就要使用相应的loader，所以laoder是把那些不是js的代码转成js代码
> >
> > 小结
> >
> > > 这个问题为啥做项目的时候不思考一下呢？有点死脑筋，直接引入css的话页面能执行啊，为什么还需要css-loader 和  style-loader呢？还有 ，webpack本来就是基于node的呀，node中根本没有css和html，webpack打包也不会打包成html和css代码呀，按这种逻辑推理也应该得出这些加载器是编译成js代码的呀，为啥就没联想到呢？
>
> **如何生成bundle.js**
>
> > 当有需求要查看bundle.js中的内容时，用什么来生成呢？
> >
> > 我想的是直接用webpack 后边加 那个js文件，然后面试的时候让我了解 npv还是nrv？   完了  这个给忘记了  真是醉了 下次面试必须带个本子记录一下！
>
> **webpack如何打包更少量，了解过吗**
>
> > 1. 去掉开发环境下的配置
> > 2. ExtractTextPlugin：提取样式到css文件
> > 3. webpack-bundle-analyzer：webpack打包文件体积和依赖关系的可视化
> > 4. CommonsChunkPlugin：提取通用模块文件
> > 5. 提取manifest:让提取的公共js的hash值不要改变
> > 6. 压缩js，css，图片
> >
> > 小结
> >
> > > 这个上边的好多还不太熟悉，webpack只有一个浅显的认识，还没有深入了解，不过，等我把js高级程序设计这本书看上两遍就正式来阅读vue文档和webpack文档！

## Vue

> **封装组件**
>
> > 是从UI界面的角度分析的；前端组件化，方便UI组件的重用
> > 就是为了拆分Vue实例的代码量，能够让我们以不同的组件，来划分不同的功能模块，将来我们需要什么样的功能，就调用什么样的组件
> >
> > 小结
> >
> > > 这只是简单的概念，给我一个使用场景我根本答不上来，这个是不是需要工作后才能明白组件到底是为了什么啊。。。